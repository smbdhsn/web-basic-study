<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      symbol 简单用法 特殊属性Symbol.toPrimitive Symbol.toStringTag
      Symbol.iterator 迭代器
    </title>
  </head>
  <body>
    <script>
      Symbol("foo") === Symbol("foo"); // false

      //   var sym = new Symbol(); // TypeError

      const sym1 = Symbol.for("key1");
      console.log(Symbol.keyFor(sym1));

      /*
       * Symbol.toPrimitive
       */
      const obj = {};
      console.log(+obj); // NaN
      console.log(`${obj}`); // [object Object]
      console.log(obj + ""); // [object Object]

      const obj2 = {
        [Symbol.toPrimitive](hint) {
          // 该函数被调用时，会被传递一个字符串参数 hint，表示要转换到的原始值的预期类型
          // hint 包含 string number default
          if (hint === "number") {
            return "100";
          }
          if (hint === "string") {
            return "string";
          }

          if (hint === "default") {
            return "default";
          }
        },
      };

      console.log(+obj2); // 100
      console.log(`${obj2}`); // string
      console.log(obj2 + ""); // default

      // Symbol.toStringTag
      // 它由 Object.prototype.toString() 方法内部访问
      class ValidatorClass {
        get [Symbol.toStringTag]() {
          return "validator";
        }
      }

      console.log(Object.prototype.toString.call(new ValidatorClass()));

      function Person(name) {
        this.name = name;
      }

      Object.defineProperty(Person.prototype, Symbol.toStringTag, {
        get() {
          return "Person";
        },
      });

      console.log(Object.prototype.toString.call(new Person()));

      /*
         Symbol.iterator 生成迭代器对象
      */
      function range(from, to) {
        let index = from;

        const iterator = {
          [Symbol.iterator]() {
            return {
              next: function () {
                if (index <= to) {
                  return { done: false, value: index++ };
                }
                return { done: true, value: undefined };
              },
            };
          },
        };

        return iterator;
      }

      const iterator = range(1, 4);

      for (let i of iterator) {
        console.log(i);
      }
    </script>

    <script>
      async function testC() {
        return new Promise((resolve, reject) => {
          resolve();
        });
      }

      testC().then(() => console.log(1));

      Promise.resolve()
        .then(() => console.log(2))
        .then(() => console.log(3));
    </script>
  </body>
</html>
