<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
            有 8 个图片资源的 url，已经存储在数组 urls 中（即urls = ['http://example.com/1.jpg', ...., 'http://example.com/8.jpg']），
            而且已经有一个函数 function loadImg，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。
            但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。
            请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。
        */
      var urls = [
        "https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg",
        "https://www.kkkk1000.com/images/getImgData/gray.gif",
        "https://www.kkkk1000.com/images/getImgData/Particle.gif",
        "https://www.kkkk1000.com/images/getImgData/arithmetic.png",
        "https://www.kkkk1000.com/images/getImgData/arithmetic2.gif",
        "https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg",
        "https://www.kkkk1000.com/images/getImgData/arithmetic.gif",
        "https://www.kkkk1000.com/images/wxQrCode2.png",
      ];
      const loadErrorImages = [];
      function loadImg(url, index) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = function () {
            console.log("一张图片加载完成");
            resolve({ success: true, index, url });
          };
          img.onerror = () => {
            resolve({ success: false, index, url })
          };
          img.src = url;
        });
      }

      function limitLoad(urls, handler, limit) {
        // 对数组做一个拷贝
        const sequence = [].concat(urls);
        let promises = [];

        //并发请求到最大数
        promises = sequence.splice(0, limit).map((url, index) => {
          // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标
          return handler(url)
        });

        // 利用数组的 reduce 方法来以队列的形式执行
        return sequence
          .reduce((last, url, currentIndex) => {
            return last
              .then(() => {
                // 返回最快改变状态的 Promise
                return Promise.race(promises);
              })
              .catch((err) => {
                debugger;
                // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误
                // 更重要的是防止中断整个链式调用
                console.error(err);
              })
              .then((res) => {
                const { success, url, index  } = res;
                if(!success) {
                  loadErrorImages.push(url)
                }
                // 用新的 Promise 替换掉最快改变状态的 Promise
                promises[index] = handler(sequence[currentIndex])
              });
          }, Promise.resolve())
          .then(() => {
            return Promise.allSettled(promises);
          }).then((result) => {
            for(let { status, value } of result) {
              if(!value.success) {
                loadErrorImages.push(value.url)
              }
            }
            return loadErrorImages
          });
      }
      limitLoad(urls, loadImg, 3).then(errors => {
        console.log('errors', errors);
      });

      /*
        因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用
        主要流程是
        Promise.race() 等待某个请求完成 根据完成索引替换为新的请求 继续执行Promise.race() 再替换为新的请求 没有多余请求后 执行Promise.all

        limitLoad(urls, loadImg, 3).then(() => {
            console.log('所有图片加载完成');
        }).catch(err => {
            console.error(err);
        })
      */
    </script>
  </body>
</html>
